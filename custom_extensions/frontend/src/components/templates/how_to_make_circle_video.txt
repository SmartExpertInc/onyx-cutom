# üîµ How to Make Avatar Circular with Props Configuration

## üéØ Complete Implementation Guide

---

## **Architecture Overview**

We'll add a `shape` property to avatar configuration that flows from:
```
Frontend (Template Registry) 
  ‚Üí Backend (Presentation Service) 
  ‚Üí Video Composer 
  ‚Üí Circular Mask Applied
```

---

## **Step 1: Add Shape Property to Frontend**

### **File: `onyx-cutom/custom_extensions/frontend/src/components/templates/registry.ts`**

```typescript
export interface AvatarPosition {
  x: number;
  y: number;
  width: number;
  height: number;
  backgroundColor?: string;
  shape?: 'circle' | 'rectangle';  // ‚≠ê NEW PROPERTY
  borderWidth?: number;              // Optional: border thickness
  borderColor?: string;              // Optional: border color (hex)
}

// Example: Circular avatar for profile-style slides
export const SLIDE_TEMPLATE_REGISTRY: Record<string, SlideTemplate> = {
  'soft-skills-assessment-slide': {
    id: 'soft-skills-assessment-slide',
    name: 'Soft Skills Assessment',
    category: 'assessment',
    // ... other properties ...
    avatarPosition: {
      x: 1690,
      y: 40,
      width: 170,
      height: 170,
      shape: 'circle',           // ‚≠ê Make it circular
      borderWidth: 3,            // Optional: 3px white border
      borderColor: '#ffffff',    // Optional: white border
      backgroundColor: '#f0f0f0'
    }
  },
  
  'course-overview-slide': {
    id: 'course-overview-slide',
    name: 'Course Overview',
    category: 'content',
    // ... other properties ...
    avatarPosition: {
      x: 925,
      y: 118,
      width: 935,
      height: 843,
      shape: 'rectangle',        // ‚≠ê Keep rectangular (default)
      backgroundColor: '#ffffff'
    }
  }
};
```

---

## **Step 2: Pass Shape to Backend**

### **File: `onyx-cutom/custom_extensions/frontend/src/app/projects-2/view/components/VideoEditorHeader.tsx`**

The shape property will automatically flow through the existing data pipeline:

```typescript
// This code already exists and will pass the shape property
const templateId = slide.templateId;
if (templateId) {
  const template = SLIDE_TEMPLATE_REGISTRY[templateId];
  if (template?.avatarPosition) {
    console.log('üé¨ [AVATAR_POSITION] Attaching avatar position:', template.avatarPosition);
    return {
      ...slide,
      avatarPosition: template.avatarPosition  // ‚≠ê Includes shape property
    };
  }
}
```

---

## **Step 3: Update Backend to Extract Shape**

### **File: `onyx-cutom/custom_extensions/backend/app/services/presentation_service.py`**

```python
def _extract_avatar_config(self, slide_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Extract avatar configuration from slide data
    
    Returns config with shape property for circular masking
    """
    avatar_position = slide_data.get('avatarPosition', {})
    
    return {
        'x': avatar_position.get('x', 925),
        'y': avatar_position.get('y', 118),
        'width': avatar_position.get('width', 935),
        'height': avatar_position.get('height', 843),
        'shape': avatar_position.get('shape', 'rectangle'),          # ‚≠ê NEW
        'borderWidth': avatar_position.get('borderWidth', 0),        # ‚≠ê NEW
        'borderColor': avatar_position.get('borderColor', '#ffffff'), # ‚≠ê NEW
        'backgroundColor': avatar_position.get('backgroundColor', '#ffffff')
    }
```

---

## **Step 4: Implement Circular Mask in Video Composer**

### **File: `onyx-cutom/custom_extensions/backend/app/services/simple_video_composer.py`**

Add these new methods to the `SimpleVideoComposer` class:

```python
import cv2
import numpy as np
from typing import Dict, Any, Tuple

class SimpleVideoComposer:
    
    def _hex_to_bgr(self, hex_color: str) -> Tuple[int, int, int]:
        """
        Convert hex color to BGR tuple for OpenCV
        
        Args:
            hex_color: Color in hex format (e.g., '#ffffff')
            
        Returns:
            BGR tuple (e.g., (255, 255, 255))
        """
        hex_color = hex_color.lstrip('#')
        rgb = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        return (rgb[2], rgb[1], rgb[0])  # Convert RGB to BGR
    
    
    def _apply_circular_mask(self, 
                           frame: np.ndarray, 
                           border_width: int = 0,
                           border_color: str = '#ffffff') -> np.ndarray:
        """
        Apply circular mask to avatar frame
        
        Args:
            frame: Avatar frame (NumPy array)
            border_width: Border thickness in pixels
            border_color: Border color in hex format
            
        Returns:
            Frame with circular mask and transparent background (BGRA)
        """
        height, width = frame.shape[:2]
        
        # Create circular mask
        mask = np.zeros((height, width), dtype=np.uint8)
        center = (width // 2, height // 2)
        radius = min(width, height) // 2
        
        # Draw white circle (255 = visible, 0 = transparent)
        cv2.circle(mask, center, radius, 255, -1)
        
        # Convert to BGRA if needed
        if frame.shape[2] == 3:  # BGR
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2BGRA)
        
        # Apply mask to alpha channel
        frame[:, :, 3] = mask
        
        # Add border if specified
        if border_width > 0:
            bgr_color = self._hex_to_bgr(border_color)
            cv2.circle(frame, center, radius, (*bgr_color, 255), border_width)
        
        return frame
    
    
    def _overlay_with_alpha(self, 
                          background: np.ndarray, 
                          overlay: np.ndarray, 
                          x: int, 
                          y: int) -> np.ndarray:
        """
        Overlay image with alpha channel (transparency) onto background
        
        Args:
            background: Background frame (BGR)
            overlay: Overlay frame with alpha channel (BGRA)
            x: X position to place overlay
            y: Y position to place overlay
            
        Returns:
            Composite frame
        """
        h, w = overlay.shape[:2]
        
        # Ensure we don't go out of bounds
        if y + h > background.shape[0] or x + w > background.shape[1]:
            logger.warning(f"Overlay position ({x}, {y}) with size ({w}, {h}) "
                         f"exceeds background size {background.shape}")
            return background
        
        # Get region of interest
        roi = background[y:y+h, x:x+w]
        
        # Alpha compositing
        alpha = overlay[:, :, 3] / 255.0
        alpha_3d = np.stack([alpha, alpha, alpha], axis=2)
        
        # Blend: result = foreground * alpha + background * (1 - alpha)
        overlay_bgr = overlay[:, :, :3]
        blended = (alpha_3d * overlay_bgr + (1 - alpha_3d) * roi).astype(np.uint8)
        
        # Place blended region back
        background[y:y+h, x:x+w] = blended
        
        return background
    
    
    def _process_avatar_frame(self, 
                            avatar_frame: np.ndarray, 
                            avatar_config: Dict[str, Any]) -> np.ndarray:
        """
        Process avatar frame: resize, crop, and apply shape (circular or rectangular)
        
        Args:
            avatar_frame: Raw avatar frame from video
            avatar_config: Configuration dict with x, y, width, height, shape, etc.
            
        Returns:
            Processed avatar frame ready for overlay
        """
        target_width = avatar_config['width']
        target_height = avatar_config['height']
        shape = avatar_config.get('shape', 'rectangle')
        
        # Resize avatar to target dimensions
        avatar_resized = cv2.resize(avatar_frame, (target_width, target_height))
        
        # Apply circular mask if specified
        if shape == 'circle':
            border_width = avatar_config.get('borderWidth', 0)
            border_color = avatar_config.get('borderColor', '#ffffff')
            
            avatar_processed = self._apply_circular_mask(
                avatar_resized,
                border_width=border_width,
                border_color=border_color
            )
            
            logger.info(f"Applied circular mask to avatar "
                       f"(border: {border_width}px, color: {border_color})")
        else:
            # Keep rectangular - just ensure it has alpha channel for consistency
            if avatar_resized.shape[2] == 3:
                avatar_processed = cv2.cvtColor(avatar_resized, cv2.COLOR_BGR2BGRA)
                avatar_processed[:, :, 3] = 255  # Fully opaque
            else:
                avatar_processed = avatar_resized
        
        return avatar_processed
```

---

## **Step 5: Update Frame Composition Logic**

### **Modify the `_compose_frames` method:**

```python
async def _compose_frames(self, 
                        slide_video_path: str, 
                        avatar_video_path: str, 
                        output_path: str,
                        avatar_config: Dict[str, Any]) -> bool:
    """
    Compose slide and avatar videos frame by frame
    
    Now supports both rectangular and circular avatars based on config
    """
    try:
        # Open video captures
        slide_cap = cv2.VideoCapture(slide_video_path)
        avatar_cap = cv2.VideoCapture(avatar_video_path)
        
        if not slide_cap.isOpened() or not avatar_cap.isOpened():
            logger.error("Failed to open video files")
            return False
        
        # Get video properties
        fps = slide_cap.get(cv2.CAP_PROP_FPS)
        total_frames = min(
            int(slide_cap.get(cv2.CAP_PROP_FRAME_COUNT)),
            int(avatar_cap.get(cv2.CAP_PROP_FRAME_COUNT))
        )
        
        # Extract positioning
        x = avatar_config['x']
        y = avatar_config['y']
        shape = avatar_config.get('shape', 'rectangle')
        
        logger.info(f"Composing {total_frames} frames with {shape} avatar at ({x}, {y})")
        
        # Create video writer
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        writer = cv2.VideoWriter(output_path, fourcc, fps, (1920, 1080))
        
        frame_count = 0
        
        while frame_count < total_frames:
            # Read frames
            slide_ret, slide_frame = slide_cap.read()
            avatar_ret, avatar_frame = avatar_cap.read()
            
            if not slide_ret or not avatar_ret:
                break
            
            # Use slide as background (resize to 1920x1080)
            background = cv2.resize(slide_frame, (1920, 1080))
            
            # Process avatar (resize + apply shape)
            avatar_processed = self._process_avatar_frame(avatar_frame, avatar_config)
            
            # Overlay avatar on background
            if shape == 'circle' or avatar_processed.shape[2] == 4:  # Has alpha
                background = self._overlay_with_alpha(
                    background, 
                    avatar_processed, 
                    x, 
                    y
                )
            else:
                # Simple rectangular overlay (old method)
                h, w = avatar_processed.shape[:2]
                background[y:y+h, x:x+w] = avatar_processed[:, :, :3]
            
            # Write frame
            writer.write(background)
            frame_count += 1
            
            # Log progress
            if frame_count % 25 == 0:
                logger.info(f"Processed {frame_count}/{total_frames} frames")
        
        # Release resources
        slide_cap.release()
        avatar_cap.release()
        writer.release()
        
        logger.info(f"Successfully composed {frame_count} frames")
        return True
        
    except Exception as e:
        logger.error(f"Error composing frames: {str(e)}")
        return False
```

---

## **Step 6: Add Type Hints (Optional but Recommended)**

### **File: `onyx-cutom/custom_extensions/backend/app/models/schemas.py`**

```python
from typing import Literal, Optional
from pydantic import BaseModel, Field

class AvatarPosition(BaseModel):
    """Avatar positioning and styling configuration"""
    
    x: int = Field(description="X coordinate (pixels from left)")
    y: int = Field(description="Y coordinate (pixels from top)")
    width: int = Field(description="Avatar width in pixels")
    height: int = Field(description="Avatar height in pixels")
    shape: Literal['circle', 'rectangle'] = Field(
        default='rectangle',
        description="Avatar shape: 'circle' for circular mask, 'rectangle' for default"
    )
    borderWidth: Optional[int] = Field(
        default=0,
        description="Border thickness in pixels (only for circular avatars)"
    )
    borderColor: Optional[str] = Field(
        default='#ffffff',
        description="Border color in hex format (e.g., '#ffffff')"
    )
    backgroundColor: Optional[str] = Field(
        default='#ffffff',
        description="Background color for avatar canvas"
    )
```

---

## üé® **Visual Examples**

### **Example 1: Small Circular Profile (Top Right)**

```typescript
avatarPosition: {
  x: 1690,
  y: 40,
  width: 170,
  height: 170,
  shape: 'circle',
  borderWidth: 3,
  borderColor: '#2563eb'  // Blue border
}
```

**Result:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Course Title        ‚ö™ üßë‚Äçüíº ‚ö™  ‚îÇ ‚Üê Small circular
‚îÇ                       ‚ö™‚ö™‚ö™     ‚îÇ   with blue border
‚îÇ                                ‚îÇ
‚îÇ  Content goes here...          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **Example 2: Large Circular (Centered)**

```typescript
avatarPosition: {
  x: 493,   // Center: (1920 - 935) / 2
  y: 118,
  width: 935,
  height: 843,
  shape: 'circle',
  borderWidth: 5,
  borderColor: '#ffffff'
}
```

**Result:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                ‚îÇ
‚îÇ         ‚ö™‚ö™‚ö™‚ö™‚ö™‚ö™‚ö™            ‚îÇ
‚îÇ       ‚ö™‚ö™     üßë‚Äçüíº    ‚ö™‚ö™         ‚îÇ ‚Üê Large centered
‚îÇ         ‚ö™‚ö™‚ö™‚ö™‚ö™‚ö™‚ö™            ‚îÇ   circular avatar
‚îÇ                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **Example 3: Standard Rectangular (No Change)**

```typescript
avatarPosition: {
  x: 925,
  y: 118,
  width: 935,
  height: 843,
  shape: 'rectangle'  // Or omit (default)
}
```

**Result:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Text content       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  and graphics       ‚îÇ        ‚îÇ ‚îÇ
‚îÇ  on the left        ‚îÇ  üßë‚Äçüíº   ‚îÇ ‚îÇ ‚Üê Rectangular
‚îÇ  side...            ‚îÇ        ‚îÇ ‚îÇ   (existing)
‚îÇ                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìä **Configuration Matrix**

| Use Case | X | Y | Width | Height | Shape | Border | Best For |
|----------|---|---|-------|--------|-------|--------|----------|
| **Profile Badge** | 1690 | 40 | 170 | 170 | circle | 3px | Minimal presence |
| **Host Circular** | 925 | 118 | 400 | 400 | circle | 5px | Modern look |
| **Standard Presenter** | 925 | 118 | 935 | 843 | rectangle | 0 | Professional courses |
| **Left-side Circular** | 80 | 551 | 500 | 500 | circle | 4px | Personal stories |

---

## üîç **How It Works (Technical Flow)**

### **1. Configuration Flow:**
```
Template Registry (TS)
  ‚Üì avatarPosition: { shape: 'circle', ... }
VideoEditorHeader (TS)
  ‚Üì Attach to slide data
Backend API
  ‚Üì Extract avatar_config
Presentation Service
  ‚Üì Pass to composer
Video Composer
  ‚Üì Apply circular mask
Final Video Output
```

### **2. Frame Processing Pipeline:**

```python
For each frame:
  1. Read slide_frame (1920√ó1080)
  2. Read avatar_frame (1080√ó1080 from Elai)
  3. Resize avatar ‚Üí (width, height)
  
  If shape == 'circle':
    4a. Create circular mask (white circle, black background)
    4b. Apply mask to alpha channel ‚Üí transparent outside circle
    4c. Add border if borderWidth > 0
    4d. Use alpha compositing to overlay
  Else:
    4. Simple rectangular placement
  
  5. Write composed frame to output video
```

### **3. Alpha Compositing Math:**

```python
# For each pixel:
result_pixel = (foreground * alpha) + (background * (1 - alpha))

# Where:
# alpha = 1.0 inside circle (fully visible)
# alpha = 0.0 outside circle (fully transparent)
# alpha = partial on anti-aliased edges (smooth)
```

---

## ‚úÖ **Testing Checklist**

- [ ] **Add shape property** to template registry (TypeScript)
- [ ] **Verify data flow** in browser console (check avatarPosition object)
- [ ] **Add circular mask methods** to `simple_video_composer.py`
- [ ] **Update `_compose_frames`** to use new methods
- [ ] **Test with circular avatar** (shape: 'circle')
- [ ] **Test with rectangular avatar** (shape: 'rectangle' or omitted)
- [ ] **Test border rendering** (borderWidth: 3, borderColor: '#ffffff')
- [ ] **Verify video quality** (no artifacts around circle edges)
- [ ] **Check browser compatibility** (Chrome, Safari, Firefox)

---

## üöÄ **Quick Start Commands**

```bash
# 1. Edit frontend template registry
vim onyx-cutom/custom_extensions/frontend/src/components/templates/registry.ts

# 2. Add circular mask methods to composer
vim onyx-cutom/custom_extensions/backend/app/services/simple_video_composer.py

# 3. Restart backend
cd onyx-cutom/custom_extensions/backend
python -m uvicorn app.main:app --reload

# 4. Rebuild frontend
cd onyx-cutom/custom_extensions/frontend
npm run build

# 5. Test video generation
# Generate a presentation with soft-skills-assessment-slide
```

---

## üí° **Pro Tips**

1. **Anti-aliasing**: OpenCV's `cv2.circle()` with thickness `-1` provides smooth edges automatically

2. **Performance**: Circular masking adds ~5-10% processing time (negligible for quality gain)

3. **Border optimization**: Only compute border if `borderWidth > 0` to save cycles

4. **Aspect ratio**: For perfect circles, ensure `width == height` in avatarPosition config

5. **Debugging**: Add this to see mask quality:
   ```python
   cv2.imwrite('/tmp/debug_mask.png', mask)  # Save mask for inspection
   ```

---

## üéØ **Expected Output**

**Before (Rectangular):**
- ‚úÖ Works with all templates
- ‚ùå Looks boxy for small profile pictures
- ‚ùå Less modern aesthetic

**After (Circular with Props):**
- ‚úÖ Configurable per template
- ‚úÖ Professional circular profiles
- ‚úÖ Optional borders and styling
- ‚úÖ Backward compatible (default: rectangle)

---

**This implementation gives you full control over avatar shapes through simple template configuration!** üé®‚ú®